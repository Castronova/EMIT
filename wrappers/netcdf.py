
import stdlib
import netCDF4
import wrappers
from wrappers import base
from utilities import geometry

# http://www.hydro.washington.edu/~jhamman/hydro-logic/blog/2013/10/12/plot-netcdf-data/

class Wrapper(base.BaseWrapper):

    def __init__(self, args):
        super(Wrapper, self).__init__(self)

        handle = netCDF4.Dataset(args['ncpath'], 'r')

        variables = handle.variables.keys()

        # make sure time is a variable in this file
        assert args['timevar'] in variables

        variables.remove(args['timevar'])
        times = handle.variables[args['timevar']][:]
        assert args['ptx'] in variables
        variables.remove(args['ptx'])
        xcoords = handle.variables[args['ptx']][:]
        assert args['pty'] in variables
        ycoords = handle.variables[args['pty']][:]
        variables.remove(args['pty'])

        # loop through the remaining variables and expose them as outputs
        for var in variables:

            # create a unit
            unit = stdlib.Unit()
            unit.UnitName(handle.variables[var].units)

            # create a variable
            variable = stdlib.Variable()
            variable.VariableNameCV(handle.variables[var].name)

            # create geometries
            endidx = min(len(xcoords), len(ycoords)) # in case number of x and y coords does not match
            geoms = geometry.build_point_geometries(xcoords[:endidx], ycoords[:endidx])

            # create exchange item
            oei = stdlib.ExchangeItem(name=variable.VariableNameCV(),
                                desc = 'Autogenerated variable parsed from %s'%args['ncpath'],
                                geometry = geoms ,
                                unit = unit,
                                variable = variable,
                                type = stdlib.ExchangeItemType.OUTPUT)

            # set data
            oei.setValues2(handle.variables[var][:], times)

            # save the oei
            self.outputs(oei)


        print 'initialize complete'

    def prepare(self):
        self.status(stdlib.Status.READY)

    def type(self):
        return wrappers.Types.NETCDF

    def run(self,inputs):
        self.status(stdlib.Status.FINISHED)

    def finish(self):
        self.status(stdlib.Status.FINISHED)


